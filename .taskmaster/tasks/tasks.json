{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Tooling Configuration",
        "description": "Initialize the Astro project with the React integration. Configure all required development tools including Tailwind CSS, Biome for linting/formatting, and Vitest for testing.",
        "details": "Use `pnpm create astro@latest` with the React template. Install dependencies: `pnpm add react react-dom zustand @tanstack/react-query idb shadcn-ui tailwindcss-animate lucide-react`. Initialize Tailwind CSS with `npx astro add tailwind`. Configure `biome.json` to handle `.astro`, `.ts`, and `.tsx` files. Set up `vitest.config.ts` to work with Astro and React components, including `@astrojs/testing` and `@testing-library/react`.",
        "testStrategy": "Run `pnpm astro check` to verify TypeScript setup. Execute `pnpm biome check .` to ensure linting rules are applied. Create a sample Vitest test for a basic React component and an Astro page to confirm the testing framework is correctly configured.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Astro Project with React Integration",
            "description": "Create a new Astro project using the official `create astro` command, selecting the React template to establish the foundational project structure.",
            "dependencies": [],
            "details": "Execute `pnpm create astro@latest` in the terminal. Follow the interactive prompts to set up a new project. Select the 'Empty' template and explicitly add the 'React' integration when asked. This will generate the initial file structure including `astro.config.mjs` and `package.json`.",
            "status": "done",
            "testStrategy": "Run `pnpm dev` to start the development server and verify that the default Astro welcome page loads correctly in a browser. Then, run `pnpm astro check` to ensure the initial TypeScript configuration is valid.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install Core Application Dependencies",
            "description": "Add all necessary npm packages for state management, data fetching, UI components, and utility libraries to the project's `package.json`.",
            "dependencies": [
              1
            ],
            "details": "Use the pnpm package manager to add the following dependencies: `pnpm add react react-dom zustand @tanstack/react-query idb shadcn-ui tailwindcss-animate lucide-react`. This command will update the `package.json` and `pnpm-lock.yaml` files.",
            "status": "done",
            "testStrategy": "After installation, inspect the `package.json` file to confirm that all specified dependencies are listed. Run `pnpm install` again to ensure there are no peer dependency conflicts or installation errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate and Configure Tailwind CSS",
            "description": "Use the Astro CLI to add and configure the Tailwind CSS integration, enabling utility-first styling for all components and pages.",
            "dependencies": [
              1
            ],
            "details": "Run the command `npx astro add tailwind`. This will install `tailwindcss` and its peer dependencies, create a `tailwind.config.mjs` file, and update the `astro.config.mjs` to include the Tailwind integration. Ensure a global CSS file imports the base Tailwind styles.",
            "status": "done",
            "testStrategy": "Create a test Astro page or component. Apply several Tailwind utility classes like `bg-blue-500`, `text-white`, and `p-4`. Start the dev server and verify in the browser that these styles are correctly applied to the element.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configure Biome for Code Linting and Formatting",
            "description": "Set up Biome to enforce a consistent code style and identify potential issues across Astro, TypeScript, and React files.",
            "dependencies": [
              1
            ],
            "details": "Create a `biome.json` configuration file in the project root. Configure the `linter` and `formatter` to recognize `.astro`, `.ts`, and `.tsx` files. Add scripts to `package.json` for checking and formatting the code, such as `\"lint\": \"biome check .\"` and `\"format\": \"biome format --write .\"`.",
            "status": "done",
            "testStrategy": "Run `pnpm biome check .` on the existing codebase to ensure it passes without errors. Intentionally introduce a formatting mistake in a file, run `pnpm biome format --write .`, and verify that the tool automatically corrects the mistake.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Set Up Vitest for Unit and Component Testing",
            "description": "Configure the Vitest testing framework to support testing for both Astro pages and React components within the project.",
            "dependencies": [
              1
            ],
            "details": "Install necessary dev dependencies: `vitest`, `@astrojs/testing`, `@testing-library/react`, and `jsdom`. Create a `vitest.config.ts` file and configure it to use the Astro plugin and the `jsdom` environment. Add a `\"test\": \"vitest\"` script to `package.json`.",
            "status": "done",
            "testStrategy": "Create a basic React component test file (`*.test.tsx`) using React Testing Library to assert that a component renders correctly. Create a basic Astro page test (`*.test.ts`) using `@astrojs/testing` to load a page and check for an element. Run `pnpm test` and confirm all tests pass.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 2,
        "title": "Static Data Layer and Profile Loading",
        "description": "Created the `profiles.json` data structure and implemented a service to load and parse this data for the game. TanStack Query is used to manage data fetching, even for local static assets, establishing a consistent pattern for future remote data.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Successfully created `public/data/profiles.json` with 8 sample profiles across 6 categories, each with 20 clues, conforming to the PRD JSON schema. Implemented a `useProfiles` hook in `src/hooks/useProfiles.ts` using TanStack Query with proper error handling and TypeScript typing. Defined comprehensive TypeScript interfaces (`Profile`, `Player`, `GameSession`, `TurnState`, `ProfilesData`) in `src/types/models.ts`. The TanStack Query provider was configured in `src/components/QueryProvider.tsx` with a 5-minute stale time and refetch on window focus disabled.",
        "testStrategy": "Comprehensive unit tests were created in `src/hooks/__tests__/useProfiles.test.tsx` using Vitest, covering success, loading, and error scenarios. All 7 tests are passing. Quality checks including linting, type checking, and build are all passing. The `profiles.json` file is validated by successful parsing within the application and tests.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interfaces for Profile and GameSession",
            "description": "Create TypeScript interfaces for the `Profile` and `GameSession` data models based on the specifications in the PRD to ensure type safety throughout the application.",
            "dependencies": [],
            "details": "In a new file, `src/types/models.ts`, define and export the `Profile` interface, including fields like `id`, `name`, `avatar`, etc. Also, define the `GameSession` interface which will likely contain an array of `Profile` objects.",
            "status": "done",
            "testStrategy": "Code will be validated by the TypeScript compiler during the build process. No specific unit tests are required for interfaces, but they will be used in subsequent tests.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create and Populate profiles.json with Sample Data",
            "description": "Create the `profiles.json` file in the `public/data/` directory and populate it with a sample list of profiles that conform to the `Profile` interface.",
            "dependencies": [
              1
            ],
            "details": "The file should contain a JSON array of profile objects. Each object must match the structure defined in the `Profile` TypeScript interface. Include at least 5-10 sample profiles with varied data for testing purposes.",
            "status": "done",
            "testStrategy": "Manually verify the JSON structure. A later subtask will involve programmatic validation of this file against a schema or by parsing it in a test.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Set Up TanStack Query Provider in the Astro Application",
            "description": "Integrate TanStack Query into the Astro/React application by setting up the `QueryClient` and wrapping the root React component or island with the `QueryClientProvider`.",
            "dependencies": [],
            "details": "Create a new `QueryClient` instance. In the main Astro layout or a specific React island wrapper, import `QueryClient` and `QueryClientProvider`. Wrap the component tree with `<QueryClientProvider client={queryClient}>` to make the client available to all child components.",
            "status": "done",
            "testStrategy": "Manual verification by ensuring the application still renders correctly after wrapping it with the provider. The success of the next subtask will implicitly confirm this setup.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement `useProfiles` Hook with TanStack Query",
            "description": "Create a custom React hook (`useProfiles`) that uses TanStack Query's `useQuery` to fetch and manage the profile data from `/data/profiles.json`.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "The hook will define a query key (e.g., `['profiles']`). The query function will use the `fetch` API to get `/data/profiles.json`, then parse the response as JSON. The hook should return the query result, including `data`, `isLoading`, and `error` states. Ensure the fetched data is typed as `Profile[]`.",
            "status": "done",
            "testStrategy": "This hook will be tested in the next subtask. Manual testing can be done by integrating the hook into a temporary React component to display the loading state and the fetched data.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write Unit Tests for `useProfiles` Hook and Validate JSON",
            "description": "Create unit tests for the `useProfiles` hook using Vitest and React Testing Library. The tests should mock the `fetch` API and verify the hook's behavior in different states (loading, success, error).",
            "dependencies": [
              2,
              4
            ],
            "details": "Using Vitest's mocking capabilities, mock the global `fetch` function to return a successful response with sample profile data and also to simulate a network error. Assert that the hook returns the correct data and state transitions. Add a separate test script or step to parse `public/data/profiles.json` to ensure it's valid JSON.",
            "status": "done",
            "testStrategy": "Run `pnpm test` to execute the Vitest unit tests. The tests should cover success, loading, and error scenarios for the data fetching hook. The JSON validation can be a simple script that reads and parses the file.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-11-09T18:52:16.737Z"
      },
      {
        "id": 3,
        "title": "Game Session State Management with Zustand",
        "description": "A global state management store has been set up using Zustand to handle the entire game session, including players, scores, turn state, and remaining profiles. This store serves as the single source of truth for all interactive React components.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "The Zustand store has been fully implemented in `src/stores/gameStore.ts` (commit 8e85ea4). It manages the `GameState` (extending `GameSession`) and includes all required actions: `createGame`, `startGame`, `nextClue`, `passTurn`, `awardPoints`, and `endGame`. The implementation includes game status tracking ('pending', 'active', 'completed'), wraparound turn cycling for players, and a scoring formula of `20 - (cluesRead - 1)` for correct answers. Full validation is in place for state transitions.",
        "testStrategy": "A comprehensive unit test suite has been implemented using Vitest in `src/stores/__tests__/gameStore.test.ts`. The suite contains 46 passing tests that cover all store actions, state mutations, edge cases (e.g., non-existent players), and error conditions, ensuring the reliability of the state management logic.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Zustand Store and Define State Shape",
            "description": "Create the basic structure for the game session store using Zustand. This includes installing the library, creating the store file, and defining the TypeScript interfaces for the game state (e.g., GameSession, Player, Turn).",
            "dependencies": [],
            "details": "Create a file `src/stores/gameStore.ts`. Use `create` from 'zustand' to initialize the store. Define the `GameState` interface including properties like `players`, `scores`, `currentTurn`, `remainingProfiles`, and `gameStatus`. Set the initial state for a new, unstarted game.",
            "status": "done",
            "testStrategy": "Verify the store initializes without errors. Write a simple unit test using Vitest to check that the initial state matches the expected default values.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement `createGame` and `startGame` Actions",
            "description": "Add the actions to the Zustand store for initializing a new game session with players and officially starting the game with a selected category.",
            "dependencies": [
              1
            ],
            "details": "Implement the `createGame(playerNames: string[])` action to populate the `players` array and initialize their scores to zero. Implement the `startGame(category: string)` action to set the game category and change the `gameStatus` from 'pending' to 'active'.",
            "status": "done",
            "testStrategy": "Write unit tests for `createGame` to ensure it correctly creates player objects from a list of names. Test `startGame` to verify it updates the `gameStatus` and `category` fields correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement `nextClue` and `passTurn` Actions",
            "description": "Develop the actions responsible for managing the core gameplay loop: advancing to the next clue for the current player and passing the turn to the next player.",
            "dependencies": [
              2
            ],
            "details": "Implement the `nextClue()` action, which should increment the clue index for the current turn. Implement the `passTurn()` action, which should update the `currentTurn` state to point to the next player in the sequence, handling wraparound from the last player to the first.",
            "status": "done",
            "testStrategy": "Test `nextClue` to ensure it increments the clue counter and doesn't exceed the maximum number of clues. Test `passTurn` with multiple players to verify it correctly cycles through the player list.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement `awardPoints` Action",
            "description": "Create the action to award points to a specific player for a correct answer. This is a critical part of the game's scoring logic.",
            "dependencies": [
              2
            ],
            "details": "Implement the `awardPoints(playerId: string)` action. This function will find the player by their ID in the state, automatically calculate the points to award based on the scoring formula, add those points to the player's current score, and update the state.",
            "status": "done",
            "testStrategy": "Write unit tests to verify that `awardPoints` correctly adds points to the specified player's score. Test edge cases like a non-existent `playerId` and awarding zero or negative points.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement `endGame` Action",
            "description": "Add the final action to the store that concludes the game session, transitioning the state to a 'finished' or 'completed' status.",
            "dependencies": [
              2
            ],
            "details": "Implement the `endGame()` action. This action should change the `gameStatus` to 'completed'. It could also perform any final calculations or state cleanup if necessary, preparing the state for display on a final scoreboard.",
            "status": "done",
            "testStrategy": "Test the `endGame` action to ensure it correctly updates the `gameStatus` property in the store. Verify that other actions might be disabled or behave differently when the game status is 'completed'.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Player Setup and Game Creation UI",
        "description": "Develop the initial screen where the Master of Ceremonies (MC) can create a new game by entering player names. This will be an interactive React island component.",
        "details": "Create a React component, `GameSetup.tsx`, that will be hydrated as an Astro island. Use `shadcn/ui` components like `Input` for player names, `Button` for 'Add Player' and 'Start Game', and `Card` for layout. On 'Start Game', call the `createGame` action from the Zustand store with the list of player names and navigate to the main game screen.",
        "testStrategy": "Use React Testing Library to render the `GameSetup` component. Simulate user input by typing names and clicking buttons. Mock the Zustand store to verify that the correct actions are called with the expected payloads when the form is submitted.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-11-10T19:07:01.114Z"
      },
      {
        "id": 5,
        "title": "Develop Core Game Screen Layout (Mobile-First)",
        "description": "Built the main game screen layout using Astro and Tailwind CSS, focusing on a mobile-first responsive design. This screen now hosts the interactive game components and is ready for future React island integration.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "A fully responsive game screen layout was created using Astro and Tailwind CSS with a mobile-first approach. Key implementation details include:\n\n**Files Created:**\n- `src/pages/game/[sessionId].astro`: The dynamic game session page.\n- `src/pages/__tests__/game.test.ts`: Automated tests for the layout structure.\n\n**Layout & Responsive Design:**\n- **Mobile (default):** Single-column flexbox layout (`flex flex-col`).\n- **Tablet (768px+):** 2-column grid (`md:grid md:grid-cols-2`), with the clue card spanning both columns.\n- **Desktop (1024px+):** 3-column grid (`lg:grid-cols-3`).\n- The layout includes three main sections: Player List/Scoreboard, Clue Card Display, and MC Controls.\n\n**Accessibility & UX:**\n- Semantic HTML (`<section>`) with ARIA labels for main sections.\n- Minimum touch targets of 44px (`h-11`) are enforced.\n- Dark mode support is included via `dark:` variants.",
        "testStrategy": "Automated tests were created in `src/pages/__tests__/game.test.ts` to verify the layout structure. Manual testing was performed across various breakpoints (mobile, tablet, desktop) in different browsers to ensure responsiveness and visual consistency. Quality metrics were met, including 100% test coverage, no linting/type errors, and a clean build output.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Dynamic Astro Page for the Game Screen",
            "description": "Set up the file structure for the main game screen by creating a new dynamic Astro page that will host the game layout and components.",
            "dependencies": [],
            "details": "Create the file at `src/pages/game/[sessionId].astro`. This page will use a base layout component and serve as the container for the entire game interface. Add a basic `<h1>` tag as an initial placeholder.",
            "status": "done",
            "testStrategy": "Run the Astro dev server and navigate to a sample URL like `/game/test-session` to ensure the page renders without any errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Mobile-First Single-Column Layout",
            "description": "Using Tailwind CSS, implement the base single-column layout for the game screen, ensuring it is optimized for mobile viewports first.",
            "dependencies": [
              1
            ],
            "details": "Within the `[sessionId].astro` page, use Tailwind's Flexbox or Grid utilities to structure the main content areas in a single vertical column. Add appropriate padding and margins for mobile devices.",
            "status": "done",
            "testStrategy": "Use browser developer tools to view the page in a mobile viewport (e.g., 375px width). Verify that all elements are stacked vertically and there is no horizontal overflow.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Responsive Breakpoints for Tablet and Desktop",
            "description": "Extend the mobile-first layout with responsive breakpoints using Tailwind CSS to create a multi-column layout for larger screens like tablets and desktops.",
            "dependencies": [
              2
            ],
            "details": "Apply responsive utility classes like `md:grid-cols-2` or `lg:flex-row` to adapt the layout. The goal is to transition from a single-column view to a multi-column view on wider screens to make better use of the space.",
            "status": "done",
            "testStrategy": "Resize the browser window from a mobile width to a desktop width. Observe the layout shifting at the `md` and `lg` breakpoints and confirm the new column structure is applied correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Placeholders for Core Game UI Sections",
            "description": "Create and style placeholder `div` elements for the three main UI sections: the player list/scoreboard, the clue card area, and the MC controls.",
            "dependencies": [
              3
            ],
            "details": "Create three distinct `div`s within the responsive layout. Give them temporary background colors, borders, and minimum heights to make them visible. Label them accordingly. Ensure any placeholder buttons or interactive elements have a minimum size of 44x44px (e.g., using `h-11 w-11`).",
            "status": "done",
            "testStrategy": "Inspect the page on both mobile and desktop viewports. Verify that the three placeholder sections are present, correctly positioned according to the layout rules, and that interactive placeholders meet the minimum size requirement.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test and Refine Layout Across Multiple Viewports",
            "description": "Perform a final round of testing on the complete layout across a range of common device breakpoints to identify and fix any alignment, spacing, or overflow issues.",
            "dependencies": [
              4
            ],
            "details": "Use the browser's developer tools to emulate various devices (e.g., iPhone SE, iPhone 12 Pro, iPad Air, standard desktop). Check for visual consistency and ensure the layout is robust and does not break at intermediate sizes.",
            "status": "done",
            "testStrategy": "Manually test the page in Chrome, Firefox, and Safari (if available) developer tools. Document and fix any responsive bugs, such as text wrapping issues or elements overlapping incorrectly.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Turn Management and Clue Display",
        "description": "Create the interactive React component for the main game loop, which displays the active player, shows clues progressively, and handles turn advancement.",
        "details": "Develop a `GamePlay.tsx` React island. This component will subscribe to the Zustand store to get the `currentTurn` state. It will display the active player's name, the current clue number, and the clue text. Implement a 'Show Next Clue' button for the MC, which triggers the `nextClue` action in the store. Also, implement a 'Pass' button that triggers the `passTurn` action.",
        "testStrategy": "Unit test the `GamePlay` component with a mocked Zustand store. Verify that it correctly displays data from the store. Simulate clicks on 'Show Next Clue' and 'Pass' and assert that the corresponding store actions are called.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4",
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create GamePlay.tsx Component and Connect to Zustand Store",
            "description": "Set up the initial `GamePlay.tsx` file as a React island and establish a connection to the Zustand game store to subscribe to state changes, specifically focusing on the `currentTurn` state.",
            "dependencies": [],
            "details": "Create the file `src/components/GamePlay.tsx`. Import the `useGameStore` hook from the store file. Inside the component, call the hook to select and subscribe to the `currentTurn` object from the game state.",
            "status": "done",
            "testStrategy": "Render the component using React Testing Library with a mocked Zustand store provider. Verify that the component mounts without errors and can access an initial mock state.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Display Active Player and Turn Information",
            "description": "Using the state from the connected Zustand store, render the name of the currently active player and other relevant turn information.",
            "dependencies": [
              1
            ],
            "details": "Within the `GamePlay.tsx` component, access the `players` array and the `currentTurn.playerId` from the store state. Find the active player's object by matching the ID and render their name in a prominent UI element like an `<h2>` tag.",
            "status": "done",
            "testStrategy": "Unit test with a mocked store state. Provide a sample `players` array and a `currentTurn` object and assert that the correct player's name is rendered in the component's output.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Render the Current Clue Number and Text",
            "description": "Display the clue for the current turn, showing its number (e.g., \"Clue 1/5\") and the clue's text content based on the `cluesRead` state.",
            "dependencies": [
              1
            ],
            "details": "Fetch the current card and `currentTurn.cluesRead` from the store. Display the text of the clue at the index `cluesRead - 1` from the card's clues array. Also, render the progress, for example: `Clue ${currentTurn.cluesRead} of 5`.",
            "status": "done",
            "testStrategy": "Mock the store with a sample game card and a `currentTurn` state where `cluesRead` is 1. Verify that the component correctly renders the text of the first clue.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement 'Show Next Clue' Button for MC",
            "description": "Add a button labeled 'Show Next Clue'. When clicked, it should trigger the `nextClue` action in the Zustand store, causing the component to re-render with the next clue.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create a `<button>` element in the JSX. Add an `onClick` handler that calls the `nextClue` action, which should be destructured from the `useGameStore` hook. Ensure this button is only visible or enabled for the Master of Ceremonies (MC) role.",
            "status": "done",
            "testStrategy": "Using React Testing Library, find the button and simulate a click event. Mock the `nextClue` store action and assert that it was called exactly once after the click.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement 'Pass' Button and Action",
            "description": "Add a 'Pass' button that allows the MC to skip the current player's turn. Clicking this button should trigger the `passTurn` action in the Zustand store.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a `<button>` element for passing the turn. Its `onClick` handler should call the `passTurn` action from the `useGameStore` hook. The component will then re-render to show the next player's turn based on the updated store state.",
            "status": "done",
            "testStrategy": "Simulate a click on the 'Pass' button using React Testing Library. Verify that the mocked `passTurn` action from the store is called, and check that the component subsequently displays the next player's name.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Swipe-to-Reveal Answer Component",
        "description": "Build the swipeable card component that hides the answer. The MC can swipe right to reveal the answer for a 3-second timeout before it automatically hides again.",
        "details": "Create a `RevealAnswer.tsx` React component. Use a gesture library like `framer-motion` or a lightweight custom hook to detect a right swipe. The component's state will manage the revealed status. On reveal, display the answer and use a `setTimeout` to hide it after 3000ms. The answer text will be fetched from the game state.",
        "testStrategy": "In Vitest, use React Testing Library to render the component. Simulate the swipe gesture (if possible with the chosen library's testing utilities) or expose a test-only prop to trigger the reveal. Use `jest.useFakeTimers()` to control the `setTimeout` and verify that the answer hides automatically after the specified duration.",
        "priority": "high",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold RevealAnswer Component with State",
            "description": "Create the basic `RevealAnswer.tsx` file and set up the internal state to manage the visibility of the answer.",
            "dependencies": [],
            "details": "Create the file `src/components/RevealAnswer.tsx`. Use the `useState` hook to create a boolean state variable, `isRevealed`, initialized to `false`. The component will conditionally render placeholder content based on this state for now.",
            "status": "done",
            "testStrategy": "Using Vitest and React Testing Library, render the component and assert that the answer area is not visible by default.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate Gesture Library for Swiping",
            "description": "Add and configure a gesture library, such as `framer-motion`, to the component to enable drag detection.",
            "dependencies": [
              1
            ],
            "details": "Install `framer-motion` as a project dependency. In `RevealAnswer.tsx`, import `motion` and wrap the main interactive element in a `<motion.div>` component, enabling the `drag` prop.",
            "status": "done",
            "testStrategy": "This is an integration step. Verification will be part of the test for the swipe logic in the next subtask.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Swipe-Right Gesture to Reveal Answer",
            "description": "Connect the gesture library to the component's state. A right swipe should set the `isRevealed` state to true.",
            "dependencies": [
              2
            ],
            "details": "Use the `onDragEnd` prop from `framer-motion`. In the event handler, check the drag offset and velocity to confirm a right swipe gesture. If the gesture is detected, call the state setter to change `isRevealed` to `true`.",
            "status": "done",
            "testStrategy": "Mock the gesture handler or use a test-only prop to simulate a successful swipe. Assert that the component's state updates and the answer content becomes visible.",
            "updatedAt": "2025-11-11T12:53:16.284Z",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Timed Auto-Hide Functionality",
            "description": "When the answer is revealed, start a 3-second timer that automatically hides the answer by resetting the component's state.",
            "dependencies": [
              3
            ],
            "details": "Use a `useEffect` hook that triggers when `isRevealed` becomes `true`. Inside the effect, initiate a `setTimeout` for 3000ms. The timeout's callback will set `isRevealed` back to `false`. Remember to include a cleanup function to clear the timer if the component unmounts.",
            "status": "done",
            "testStrategy": "In Vitest, use `jest.useFakeTimers()`. After triggering the reveal, advance the timers by 3000ms using `jest.advanceTimersByTime(3000)` and verify that the answer content is hidden again.",
            "parentId": "undefined",
            "updatedAt": "2025-11-11T12:53:16.285Z"
          },
          {
            "id": 5,
            "title": "Connect to Game State and Apply Final Styling",
            "description": "Fetch the actual answer text from the global game state and apply visual styles for both the hidden and revealed states.",
            "dependencies": [
              1
            ],
            "details": "Import and use the Zustand store hook to get the current question's answer. Display this answer text when `isRevealed` is true. Add CSS to style the component, providing clear visual feedback for the swipe action and the revealed state.",
            "status": "done",
            "testStrategy": "Mock the Zustand store provider in the test setup. Provide a mock answer and verify that this specific text is rendered correctly when the component is in its revealed state.",
            "parentId": "undefined",
            "updatedAt": "2025-11-11T12:54:05.573Z"
          }
        ],
        "updatedAt": "2025-11-11T12:54:05.573Z"
      },
      {
        "id": 8,
        "title": "Implement MC Scoring Interaction",
        "description": "Enable the MC to award points to the player who guesses correctly. The player list should be interactive, allowing the MC to tap a player's name to trigger the scoring logic.",
        "details": "Enhance the player list UI within the `GamePlay.tsx` island. Make each player's name a clickable element (e.g., a `Button`). When the MC clicks a player's name, call the `awardPoints(playerId)` action from the Zustand store. The store action will calculate points based on `TOTAL_CLUES - (cluesRead - 1)` and update the player's score.",
        "testStrategy": "Test the scoring interaction within the `GamePlay` component test suite. Simulate a click on a player's name and verify that the `awardPoints` action is dispatched with the correct `playerId`. In the Zustand store tests, ensure the point calculation logic is correct for various `cluesRead` values.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Integrate Game Session Persistence with IndexedDB",
        "description": "Persist the game session state to IndexedDB to allow players to resume a game after a page refresh. Use the 'idb' library for a clean, promise-based API.",
        "details": "Create a utility module for IndexedDB interactions using the `idb` library. Subscribe to the Zustand store. Whenever the state changes, serialize it and save it to an IndexedDB object store. When the application loads, attempt to read from IndexedDB to rehydrate the store's initial state. This ensures the game state (players, scores, current turn) persists.",
        "testStrategy": "This is difficult to test in a pure Node environment. Write integration tests that run in a browser context (e.g., using Playwright or Cypress if added, or manual testing). For unit tests, mock the `idb` library to verify that the save/load functions are called correctly on store updates and application initialization.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Final Scoreboard and Game End Flow",
        "description": "Create the final scoreboard view that is displayed when the MC ends the game. The scoreboard should list all players ranked by their final scores.",
        "details": "Create a new Astro page `src/pages/scoreboard.astro` or a conditional view within the main game island. This component will read the final player list from the Zustand store, sort it by score in descending order, and display the results using a `Table` from `shadcn/ui`. Add a 'Finish Game' button to the main game UI that triggers the `endGame` action and navigates to this view.",
        "testStrategy": "Use React Testing Library to test the scoreboard component with a mock state containing a list of players with various scores. Verify that the players are rendered in the correct order. Use `@astrojs/testing` to test the navigation flow from the game page to the scoreboard page upon ending the game.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `endGame` Action in Zustand Store",
            "description": "Implement the `endGame` action in the game's Zustand store. This action will update the game state to indicate that the game has concluded, for example, by setting a `gameStatus` property to 'finished'.",
            "dependencies": [],
            "details": "In the primary game store file (e.g., `src/store/gameStore.ts`), add an `endGame` function to the store's actions. This function should modify the state to set a property like `gameStatus: 'finished'`. This status will be used by UI components to conditionally render different views.",
            "status": "done",
            "testStrategy": "Write a unit test for the Zustand store using Vitest. Call the `endGame` action and assert that the `gameStatus` in the state is correctly updated to 'finished'."
          },
          {
            "id": 2,
            "title": "Add 'Finish Game' Button to MC Game View",
            "description": "Integrate a 'Finish Game' button into the main game interface, visible only to the Master of Ceremonies (MC). This button will trigger the game-ending logic.",
            "dependencies": [
              1
            ],
            "details": "In the `GamePlay.tsx` component, add a new `Button` component from `shadcn/ui`. This button should be conditionally rendered based on the user's role (isMC). The button's `onClick` handler should call the `endGame` action from the Zustand store.",
            "status": "done",
            "testStrategy": "Using React Testing Library, render the `GamePlay.tsx` component with a mock store where the user is the MC. Find the 'Finish Game' button, simulate a click, and verify that the mocked `endGame` store action was called."
          },
          {
            "id": 3,
            "title": "Create Scoreboard Astro Page and Component Structure",
            "description": "Create a new Astro page at `src/pages/scoreboard.astro` and a corresponding React component `Scoreboard.tsx` to display the final game results.",
            "dependencies": [],
            "details": "Create the file `src/pages/scoreboard.astro`. Inside this file, import and render a new React island component, `<Scoreboard client:load />`. Also, create the initial `Scoreboard.tsx` file in `src/components/`, which will serve as the container for the scoreboard UI.",
            "status": "in-progress",
            "testStrategy": "Use `@astrojs/testing` to verify that the `/scoreboard` route renders successfully without errors. The initial test can just check for a placeholder heading to confirm the page and component are linked correctly."
          },
          {
            "id": 4,
            "title": "Implement Scoreboard Data Fetching and Rendering",
            "description": "Develop the `Scoreboard.tsx` component to fetch the player list from the Zustand store, sort players by their final score in descending order, and display the ranked list using a table.",
            "dependencies": [
              3
            ],
            "details": "In `Scoreboard.tsx`, use the Zustand store hook to subscribe to the `players` array. Implement a memoized sorting function using `useMemo` to sort the players by `score` descending. Use the `Table`, `TableHeader`, `TableRow`, `TableHead`, `TableBody`, and `TableCell` components from `shadcn/ui` to render the ranked list.",
            "status": "pending",
            "testStrategy": "Use React Testing Library to test the `Scoreboard.tsx` component. Provide a mock Zustand store with an unsorted list of players. Verify that the component renders a table and that the player rows appear in the correct, sorted order based on score."
          },
          {
            "id": 5,
            "title": "Implement Navigation to Scoreboard on Game End",
            "description": "Add logic to the main game view to automatically redirect the user to the `/scoreboard` page when the game's status changes to 'finished' in the Zustand store.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "In the `GamePlay.tsx` component, use a `useEffect` hook that subscribes to the `gameStatus` from the Zustand store. When `gameStatus` changes to 'finished', use client-side navigation (e.g., `window.location.href = '/scoreboard'`) to redirect the user to the scoreboard page.",
            "status": "pending",
            "testStrategy": "In the `GamePlay.tsx` test suite, use a mock store. Simulate the state changing so that `gameStatus` becomes 'finished'. Verify that the navigation logic (e.g., `window.location.href` assignment) is triggered. This may require mocking `window.location`."
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement Internationalization (i18n) Support",
        "description": "Integrate multi-language support using Astro's built-in i18n routing for localized pages and react-i18next for translating React island components. This includes localizing the profile data and UI text throughout the application.",
        "details": "1. **Configure Astro i18n**: Update `astro.config.mjs` to enable internationalized routing. Define a `defaultLocale` (e.g., 'en') and a list of `locales` (e.g., ['en', 'es']). Use the `routing: { prefixDefaultLocale: false }` strategy to avoid having `/en/` in the URL for the default language.\n2. **Localize Page Structure**: Create language-specific directories within `src/pages/` (e.g., `src/pages/es/`) for any static pages that need translation, or leverage Astro's `[lang]` dynamic parameter for shared layouts.\n3. **Integrate react-i18next**: Set up `react-i18next` for client-side translations within React islands. Create a configuration file (`src/i18n/config.ts`) to initialize i18next. Use `i18next-http-backend` to load translation files from `public/locales/[lang]/translation.json`. The current locale must be passed from the Astro page as a prop to the React island.\n4. **Localize Profile Data**: Modify the data loading service from Task #2. The `useProfiles` hook must be updated to fetch data from a locale-specific path, such as `/data/${locale}/profiles.json`. Create example localized data files: `public/data/en/profiles.json` and `public/data/es/profiles.json`.\n5. **Create Language Switcher**: Implement a UI component that allows users to switch between supported languages. This component should use Astro's `getRelativeLocaleUrl(locale)` utility to generate correct links for the current page in other languages.",
        "testStrategy": "1. **Unit Tests (Vitest)**: For React components using the `useTranslation` hook, mock the i18next provider and verify that components render the correct strings for a given language. Unit test the updated `useProfiles` hook to ensure it constructs the correct URL based on the locale prop passed to it.\n2. **Integration Tests (Astro Testing Library)**: Write integration tests to verify that Astro pages render with the correct `lang` attribute in the `<html>` tag. Test that the language switcher component generates the correct URLs using `getRelativeLocaleUrl`.\n3. **E2E / Manual Testing**: Perform a full smoke test for each supported locale. Navigate the entire application flow, from the home page through a full game session to the final scoreboard. Verify that all UI text is translated, localized profile data loads correctly, and routing between locales works as expected.",
        "status": "pending",
        "dependencies": [
          "2",
          "6"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Progressive Web App (PWA) Support",
        "description": "Integrate PWA features to make the application installable, work offline, and feel like a native app. This involves generating a service worker for caching assets and a web manifest for installation metadata using the vite-plugin-pwa library.",
        "details": "1. **Installation**: Add `vite-plugin-pwa` as a development dependency: `npm install vite-plugin-pwa -D`.\n2. **Configuration**: Update `astro.config.mjs` to include the PWA plugin in the Vite configuration. Configure the manifest with properties like `name`, `short_name`, `description`, `theme_color`, `background_color`, and specify paths to various icon sizes (e.g., 192x192, 512x512) in the `public/icons/` directory.\n3. **Service Worker Strategy**: Use the `generateSW` strategy within the plugin options. Configure `workbox` runtime caching rules. Create a rule for the app's static assets (JS, CSS, fonts) using a `StaleWhileRevalidate` strategy. Create a separate rule for the profiles JSON data endpoint using a `NetworkFirst` strategy to ensure users get the latest profiles when online but have a fallback for offline play.\n4. **Client-side Registration**: Create a small React component or client-side script (`<script is:inline>`) in the main layout (`src/layouts/Layout.astro`) to register the service worker. Consider using a library like `virtual:pwa-register/react` to provide users with a UI prompt to reload the page when a new version of the app is available.\n5. **Manifest Linking**: Ensure the web manifest is automatically linked in the `<head>` of the document by the plugin.",
        "testStrategy": "1. **Lighthouse Audit**: Run a Lighthouse audit in browser developer tools to validate PWA criteria, checking for installability, service worker registration, and offline support. Aim for a high PWA score.\n2. **Manual Offline Testing**: In the browser's developer tools, enable offline mode. Refresh the application to confirm that the app shell loads correctly from the cache. Verify that core functionalities, such as viewing the scoreboard and resuming a game session via IndexedDB, work as expected without a network connection.\n3. **Installation Test**: Test the 'Add to Home Screen' or 'Install App' functionality on both desktop (Chrome/Edge) and mobile (Android/iOS) devices to ensure the manifest and icons are configured correctly.\n4. **CI Verification**: Add a script to the CI pipeline that runs after the build command (`npm run build`) to verify that `dist/manifest.webmanifest` and `dist/sw.js` files are generated successfully, preventing regressions in the PWA configuration.",
        "status": "pending",
        "dependencies": [
          "9",
          "10"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Configure Vitest Test Coverage",
        "description": "Add test coverage collection and enforcement to the Vitest configuration and project scripts. Define coverage thresholds and a CI-friendly coverage report format.",
        "details": "1. Update `vitest.config.ts` to enable coverage provider (e.g., 'c8' or 'istanbul') and configure coverage reporters (text, lcov).\n2. Add an npm script `test:coverage` that runs `vitest --coverage` and outputs an `lcov` report.\n3. Set minimum coverage thresholds (e.g., 80% statements, branches, functions, and lines) in the Vitest config so the test run fails when thresholds are not met.\n4. Add documentation in `docs/` (or PRD) describing how to run coverage locally and interpret the reports.",
        "testStrategy": "1. Run `pnpm test:coverage` locally and verify that coverage artifacts are generated at `coverage/` and `coverage/lcov.info`.\n2. Add a failing test or lower the threshold to validate that the coverage enforcement fails the test run when coverage is under the threshold.\n3. Verify that CI can consume the `lcov` report for coverage badges or services like Codecov.",
        "status": "done",
        "dependencies": [
          "5"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Enable Coverage Provider and Reporters in Vitest Config",
            "description": "Update the `vitest.config.ts` file to enable a coverage provider and configure the necessary reporters for generating coverage reports.",
            "dependencies": [],
            "details": "In `vitest.config.ts`, add a `test.coverage` configuration block. Set the `provider` to 'v8' (formerly 'c8'). Configure the `reporters` array to include 'text', 'html', and 'lcov' to support both console output and CI integration.",
            "status": "done",
            "testStrategy": "After configuration, run `vitest --coverage` and verify that a `coverage/` directory is created containing an `lcov.info` file and an HTML report.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add `test:coverage` NPM Script",
            "description": "Add a dedicated npm script in `package.json` to make running tests with coverage collection simple and consistent.",
            "dependencies": [
              1
            ],
            "details": "In the `scripts` section of the `package.json` file, add a new script: `\"test:coverage\": \"vitest run --coverage\"`. Using `vitest run` ensures the tests execute once and exit, which is suitable for CI environments.",
            "status": "done",
            "testStrategy": "Run `pnpm test:coverage` from the terminal and confirm that it executes the test suite and generates the coverage artifacts as configured in the previous step.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Set and Enforce Minimum Coverage Thresholds",
            "description": "Configure minimum coverage thresholds in the Vitest configuration to ensure the test suite fails if coverage drops below the defined percentages.",
            "dependencies": [
              1
            ],
            "details": "In the `test.coverage` section of `vitest.config.ts`, add a `thresholds` object. Set minimum percentages for `statements`, `branches`, `functions`, and `lines` to 80 to enforce a baseline quality standard.",
            "status": "done",
            "testStrategy": "Temporarily lower one of the threshold values to be higher than the actual coverage. Run `pnpm test:coverage` and verify that the process exits with an error, confirming that the threshold enforcement is working.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Document Test Coverage Generation and Interpretation",
            "description": "Add documentation explaining how developers can run the coverage script locally and how to interpret the generated reports.",
            "dependencies": [
              2
            ],
            "details": "Create or update a document (e.g., `docs/testing.md` or `CONTRIBUTING.md`). Add a section that describes the `pnpm test:coverage` command and explains how to open the `coverage/index.html` file in a browser to view the detailed, line-by-line coverage report.",
            "status": "done",
            "testStrategy": "Have a team member review the documentation for clarity and accuracy. They should be able to follow the instructions to run coverage and find the report without assistance.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 14,
        "title": "Configure Git Hooks (Husky + lint-staged)",
        "description": "Configured Husky and lint-staged to run formatting, linting, and tests automatically on pre-commit and pre-push hooks. This ensures code quality and consistency before code is committed or pushed to the repository.",
        "status": "done",
        "dependencies": [
          "4",
          "5"
        ],
        "priority": "high",
        "details": "Successfully implemented Git hooks using Husky and lint-staged. Key implementation details:\n- Installed husky@9.1.7 and lint-staged@16.2.6.\n- Added a `prepare` script to `package.json` for automatic hook installation.\n- Configured a `pre-commit` hook to run lint-staged, which formats, lints, and tests staged files within the `src/` directory.\n- Configured a `pre-push` hook to run the `complete-check` script (lint, typecheck, test, build).\n- Updated `.gitignore` to exclude `.serena/` artifacts.\n- All changes were committed in `6d58bd0`.",
        "testStrategy": "Verification was completed successfully:\n1. Ran `pnpm prepare` and confirmed the `.husky` directory was created and populated.\n2. Staged a file with a deliberate linting error; the pre-commit hook correctly blocked the commit.\n3. Attempted to push a branch with failing checks; the pre-push hook correctly blocked the push.\n4. All QA checks passed, confirming the hooks work as expected.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Husky and lint-staged dependencies",
            "description": "Install husky and lint-staged as development dependencies to enable Git hooks.",
            "dependencies": [],
            "details": "Installed husky@9.1.7 and lint-staged@16.2.6 as dev dependencies using pnpm.",
            "status": "completed",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add 'prepare' script to package.json",
            "description": "Add a 'prepare' script to package.json to automatically install Husky hooks after dependencies are installed.",
            "dependencies": [
              1
            ],
            "details": "Added the script '\"prepare\": \"husky\"' to package.json to ensure hooks are installed automatically for all contributors.",
            "status": "completed",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create pre-commit hook",
            "description": "Create a pre-commit hook using Husky to run lint-staged on staged files.",
            "dependencies": [
              1,
              2
            ],
            "details": "Created the .husky/pre-commit file. This hook executes 'npx lint-staged' to run formatting, linting, and related tests on staged files before allowing a commit.",
            "status": "completed",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create pre-push hook",
            "description": "Create a pre-push hook using Husky to run a complete project check before pushing.",
            "dependencies": [
              1,
              2
            ],
            "details": "Created the .husky/pre-push file. This hook executes 'pnpm run complete-check', which includes linting, type checking, all tests, and a production build, to ensure code quality before pushing to the remote repository.",
            "status": "completed",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure lint-staged for src/ directory",
            "description": "Configure lint-staged in package.json to specify which commands to run on which files, targeting the src/ directory.",
            "dependencies": [
              1
            ],
            "details": "Configured lint-staged in package.json to process files only within the 'src/' directory. The configuration runs Biome for formatting and linting, and Vitest for related tests on staged files.",
            "status": "completed",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Update .gitignore",
            "description": "Update the .gitignore file to exclude Serena MCP artifacts.",
            "dependencies": [],
            "details": "Added the '.serena/' directory to the project's .gitignore file to prevent local AI assistant artifacts from being committed to the repository.",
            "status": "completed",
            "testStrategy": null,
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 15,
        "title": "Configure GitHub Actions CI (lint, typecheck, test, build, deploy)",
        "description": "Create a GitHub Actions workflow that runs linting, type checking, tests, coverage, and build on PRs and pushes to `main`. Add a deploy step to Cloudflare Pages using wrangler-action.",
        "details": "1. Add `.github/workflows/ci.yml` with jobs for: install (pnpm install), lint (pnpm lint), typecheck (pnpm typecheck), test (pnpm test), coverage (pnpm test:coverage), and build (pnpm build).\n2. Configure matrix runs if necessary (node versions).\n3. Add artifacts upload for coverage reports and build artifacts.\n4. Add a separate `deploy` job that runs on `workflow_run` or push to `main` and uses `cloudflare/wrangler-action` with secrets configured in repository settings (CLOUDFLARE_API_TOKEN, CLOUDFLARE_ACCOUNT_ID).",
        "testStrategy": "1. Create a branch and open a PR with an intentionally failing lint or test to confirm CI fails.\n2. Fix the issue and confirm CI passes.\n3. Verify coverage artifacts are uploaded and accessible in the workflow run UI.\n4. Verify a successful deploy to Cloudflare Pages after merging to main or via a manual trigger.",
        "status": "done",
        "dependencies": [
          "4",
          "5",
          "13",
          "14"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Base CI Workflow with Triggers and Dependency Installation",
            "description": "Initialize the `.github/workflows/ci.yml` file. Configure it to trigger on pull requests to `main` and pushes to `main`. Create the first job, `ci`, which checks out the code, sets up Node.js, and installs dependencies using `pnpm` with caching.",
            "dependencies": [],
            "details": "Use `actions/checkout@v4`, `actions/setup-node@v4` (with Node.js 24.x), and `pnpm/action-setup@v4` (with pnpm 10). The install step should run `pnpm install --frozen-lockfile`. The workflow should be named 'CI Pipeline'.",
            "status": "done",
            "testStrategy": "Push a commit with the new workflow file to a feature branch and open a PR to `main`. Verify the `ci` job runs and successfully completes the installation step.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Linting and Type Checking Steps to CI Job",
            "description": "Add two new steps to the `ci` job in `ci.yml`. The first step will run the linting command (`pnpm lint`), and the second will run the type checking command (`pnpm typecheck`). These steps ensure code quality and type safety.",
            "dependencies": [
              1
            ],
            "details": "Add `run: pnpm lint` and `run: pnpm typecheck` steps after the dependency installation step within the `ci` job. Ensure they run sequentially.",
            "status": "done",
            "testStrategy": "Introduce a deliberate linting error in a test branch and push. Verify the `lint` step fails. Fix it, then introduce a type error and verify the `typecheck` step fails. Finally, ensure the job passes with correct code.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Test Execution and Coverage Generation Steps",
            "description": "Integrate the testing and coverage generation process into the CI workflow. Add a step to the `ci` job that executes all tests and generates a coverage report using the `pnpm test:coverage` script.",
            "dependencies": [
              2
            ],
            "details": "Add a step `run: pnpm test:coverage` to the `ci` job. This relies on the Vitest coverage configuration from Task 13 being in place. This step should run after linting and type checking have passed.",
            "status": "done",
            "testStrategy": "Create a PR with a failing test to ensure the CI job fails at this step. After fixing it, verify the job passes and that the coverage command runs successfully.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Production Build Step to CI Job",
            "description": "Add a final validation step to the `ci` job to ensure the application can be built successfully for production. This step will run the `pnpm build` command.",
            "dependencies": [
              3
            ],
            "details": "Add a `run: pnpm build` step at the end of the `ci` job's validation sequence. This step confirms that all code and assets can be compiled and bundled without errors.",
            "status": "done",
            "testStrategy": "Push a commit and verify the build step completes successfully. If possible, introduce a configuration error that would only be caught at build time and confirm the step fails.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure Upload of Build and Coverage Artifacts",
            "description": "Add steps to the CI workflow to upload the generated coverage report and the production build output as artifacts. This allows for inspection of coverage results and provides the build files for a potential deployment job.",
            "dependencies": [
              4
            ],
            "details": "Use the `actions/upload-artifact@v4` action. Create one step to upload the `coverage/` directory as a 'coverage-report' artifact. Create a second step to upload the `dist/` directory as a 'build-artifacts' artifact.",
            "status": "done",
            "testStrategy": "After a successful workflow run, navigate to the run's summary page on GitHub and verify that both 'coverage-report' and 'build-artifacts' are present and can be downloaded.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement Conditional Deploy Job to Cloudflare Pages",
            "description": "Add a new job, `deploy`, to the workflow that handles deployment to Cloudflare Pages. This job should be conditional, running only on successful pushes to the `main` branch, and must depend on the `ci` job's success.",
            "dependencies": [
              5
            ],
            "details": "Create a `deploy` job that `needs: ci`. Add an `if: github.ref == 'refs/heads/main' && github.event_name == 'push'` condition. Use `actions/download-artifact` to get the 'build-artifacts'. Configure the Cloudflare Pages deploy step using `cloudflare/wrangler-action@v3` with the `pages-deploy` command. Store the Cloudflare API token and account ID as encrypted repository secrets (`CLOUDFLARE_API_TOKEN`, `CLOUDFLARE_ACCOUNT_ID`).",
            "status": "done",
            "testStrategy": "Configure the Cloudflare API token and account ID secrets in the repository settings. Push a change to a feature branch and open a PR; verify the `deploy` job is skipped. Merge the PR to `main` and verify the `deploy` job runs and successfully triggers a deployment on Cloudflare Pages.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-11T12:54:05.574Z",
      "taskCount": 15,
      "completedCount": 10,
      "tags": [
        "master"
      ],
      "created": "2025-11-11T13:49:48.585Z",
      "description": "Tasks for master context",
      "updated": "2025-11-11T21:58:07.960Z"
    }
  }
}