{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Tooling Configuration",
        "description": "Initialize the Astro project with the React integration. Configure all required development tools including Tailwind CSS, Biome for linting/formatting, and Vitest for testing.",
        "details": "Use `pnpm create astro@latest` with the React template. Install dependencies: `pnpm add react react-dom zustand @tanstack/react-query idb shadcn-ui tailwindcss-animate lucide-react`. Initialize Tailwind CSS with `npx astro add tailwind`. Configure `biome.json` to handle `.astro`, `.ts`, and `.tsx` files. Set up `vitest.config.ts` to work with Astro and React components, including `@astrojs/testing` and `@testing-library/react`.",
        "testStrategy": "Run `pnpm astro check` to verify TypeScript setup. Execute `pnpm biome check .` to ensure linting rules are applied. Create a sample Vitest test for a basic React component and an Astro page to confirm the testing framework is correctly configured.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Astro Project with React Integration",
            "description": "Create a new Astro project using the official `create astro` command, selecting the React template to establish the foundational project structure.",
            "dependencies": [],
            "details": "Execute `pnpm create astro@latest` in the terminal. Follow the interactive prompts to set up a new project. Select the 'Empty' template and explicitly add the 'React' integration when asked. This will generate the initial file structure including `astro.config.mjs` and `package.json`.",
            "status": "done",
            "testStrategy": "Run `pnpm dev` to start the development server and verify that the default Astro welcome page loads correctly in a browser. Then, run `pnpm astro check` to ensure the initial TypeScript configuration is valid."
          },
          {
            "id": 2,
            "title": "Install Core Application Dependencies",
            "description": "Add all necessary npm packages for state management, data fetching, UI components, and utility libraries to the project's `package.json`.",
            "dependencies": [
              1
            ],
            "details": "Use the pnpm package manager to add the following dependencies: `pnpm add react react-dom zustand @tanstack/react-query idb shadcn-ui tailwindcss-animate lucide-react`. This command will update the `package.json` and `pnpm-lock.yaml` files.",
            "status": "done",
            "testStrategy": "After installation, inspect the `package.json` file to confirm that all specified dependencies are listed. Run `pnpm install` again to ensure there are no peer dependency conflicts or installation errors."
          },
          {
            "id": 3,
            "title": "Integrate and Configure Tailwind CSS",
            "description": "Use the Astro CLI to add and configure the Tailwind CSS integration, enabling utility-first styling for all components and pages.",
            "dependencies": [
              1
            ],
            "details": "Run the command `npx astro add tailwind`. This will install `tailwindcss` and its peer dependencies, create a `tailwind.config.mjs` file, and update the `astro.config.mjs` to include the Tailwind integration. Ensure a global CSS file imports the base Tailwind styles.",
            "status": "done",
            "testStrategy": "Create a test Astro page or component. Apply several Tailwind utility classes like `bg-blue-500`, `text-white`, and `p-4`. Start the dev server and verify in the browser that these styles are correctly applied to the element."
          },
          {
            "id": 4,
            "title": "Configure Biome for Code Linting and Formatting",
            "description": "Set up Biome to enforce a consistent code style and identify potential issues across Astro, TypeScript, and React files.",
            "dependencies": [
              1
            ],
            "details": "Create a `biome.json` configuration file in the project root. Configure the `linter` and `formatter` to recognize `.astro`, `.ts`, and `.tsx` files. Add scripts to `package.json` for checking and formatting the code, such as `\"lint\": \"biome check .\"` and `\"format\": \"biome format --write .\"`.",
            "status": "done",
            "testStrategy": "Run `pnpm biome check .` on the existing codebase to ensure it passes without errors. Intentionally introduce a formatting mistake in a file, run `pnpm biome format --write .`, and verify that the tool automatically corrects the mistake."
          },
          {
            "id": 5,
            "title": "Set Up Vitest for Unit and Component Testing",
            "description": "Configure the Vitest testing framework to support testing for both Astro pages and React components within the project.",
            "dependencies": [
              1
            ],
            "details": "Install necessary dev dependencies: `vitest`, `@astrojs/testing`, `@testing-library/react`, and `jsdom`. Create a `vitest.config.ts` file and configure it to use the Astro plugin and the `jsdom` environment. Add a `\"test\": \"vitest\"` script to `package.json`.",
            "status": "done",
            "testStrategy": "Create a basic React component test file (`*.test.tsx`) using React Testing Library to assert that a component renders correctly. Create a basic Astro page test (`*.test.ts`) using `@astrojs/testing` to load a page and check for an element. Run `pnpm test` and confirm all tests pass."
          }
        ]
      },
      {
        "id": 2,
        "title": "Static Data Layer and Profile Loading",
        "description": "Create the `profiles.json` data structure and implement a service to load and parse this data for the game. Use TanStack Query to manage data fetching, even for local static assets, to establish a consistent pattern for future remote data.",
        "details": "Create a `public/data/profiles.json` file adhering to the schema defined in the PRD. Implement a data fetching hook using TanStack Query (`useQuery`) within a React island. The query function will use the `fetch` API to get `/data/profiles.json`. Define TypeScript interfaces for `Profile` and `GameSession` based on the PRD's data model to ensure type safety.",
        "testStrategy": "Write a unit test using Vitest to mock the `fetch` call and verify that the data loading hook correctly parses the JSON and returns the profile data in the expected format. Validate the `profiles.json` file against the provided JSON schema.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Game Session State Management with Zustand",
        "description": "Set up a global state management store using Zustand to handle the entire game session, including players, scores, turn state, and remaining profiles. This store will be the single source of truth for all interactive React components.",
        "details": "Create a Zustand store (`create` from 'zustand') that manages the `GameSession` state object. The store should include actions to: `createGame(playerNames: string[])`, `startGame(category: string)`, `nextClue()`, `passTurn()`, `awardPoints(playerId: string)`, and `endGame()`. The state should be typed using the interfaces defined in the PRD.",
        "testStrategy": "Write unit tests for the Zustand store using Vitest. Test each action individually to ensure it correctly mutates the state. For example, verify that `createGame` populates the `players` array and `awardPoints` correctly calculates and adds points to the specified player.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Player Setup and Game Creation UI",
        "description": "Develop the initial screen where the Master of Ceremonies (MC) can create a new game by entering player names. This will be an interactive React island component.",
        "details": "Create a React component, `GameSetup.tsx`, that will be hydrated as an Astro island. Use `shadcn/ui` components like `Input` for player names, `Button` for 'Add Player' and 'Start Game', and `Card` for layout. On 'Start Game', call the `createGame` action from the Zustand store with the list of player names and navigate to the main game screen.",
        "testStrategy": "Use React Testing Library to render the `GameSetup` component. Simulate user input by typing names and clicking buttons. Mock the Zustand store to verify that the correct actions are called with the expected payloads when the form is submitted.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop Core Game Screen Layout (Mobile-First)",
        "description": "Build the main game screen layout using Astro and Tailwind CSS, focusing on a mobile-first responsive design. This screen will host the interactive game components.",
        "details": "Create an Astro page, e.g., `src/pages/game/[sessionId].astro`. Use Tailwind CSS utility classes to implement a single-column layout for mobile and a multi-column layout for tablet/desktop. The layout should include placeholders for the player list/scoreboard, the clue card, and MC controls. Ensure touch targets are appropriately sized (>= 44px).",
        "testStrategy": "Use `@astrojs/testing`'s Container API to render the Astro page and assert that the basic layout structure is present. Manually test the responsiveness in a browser's developer tools across different breakpoints (mobile, tablet, desktop) to ensure the layout adapts correctly.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Turn Management and Clue Display",
        "description": "Create the interactive React component for the main game loop, which displays the active player, shows clues progressively, and handles turn advancement.",
        "details": "Develop a `GamePlay.tsx` React island. This component will subscribe to the Zustand store to get the `currentTurn` state. It will display the active player's name, the current clue number, and the clue text. Implement a 'Show Next Clue' button for the MC, which triggers the `nextClue` action in the store. Also, implement a 'Pass' button that triggers the `passTurn` action.",
        "testStrategy": "Unit test the `GamePlay` component with a mocked Zustand store. Verify that it correctly displays data from the store. Simulate clicks on 'Show Next Clue' and 'Pass' and assert that the corresponding store actions are called.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Swipe-to-Reveal Answer Component",
        "description": "Build the swipeable card component that hides the answer. The MC can swipe right to reveal the answer for a 3-second timeout before it automatically hides again.",
        "details": "Create a `RevealAnswer.tsx` React component. Use a gesture library like `framer-motion` or a lightweight custom hook to detect a right swipe. The component's state will manage the revealed status. On reveal, display the answer and use a `setTimeout` to hide it after 3000ms. The answer text will be fetched from the game state.",
        "testStrategy": "In Vitest, use React Testing Library to render the component. Simulate the swipe gesture (if possible with the chosen library's testing utilities) or expose a test-only prop to trigger the reveal. Use `jest.useFakeTimers()` to control the `setTimeout` and verify that the answer hides automatically after the specified duration.",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement MC Scoring Interaction",
        "description": "Enable the MC to award points to the player who guesses correctly. The player list should be interactive, allowing the MC to tap a player's name to trigger the scoring logic.",
        "details": "Enhance the player list UI within the `GamePlay.tsx` island. Make each player's name a clickable element (e.g., a `Button`). When the MC clicks a player's name, call the `awardPoints(playerId)` action from the Zustand store. The store action will calculate points based on `TOTAL_CLUES - (cluesRead - 1)` and update the player's score.",
        "testStrategy": "Test the scoring interaction within the `GamePlay` component test suite. Simulate a click on a player's name and verify that the `awardPoints` action is dispatched with the correct `playerId`. In the Zustand store tests, ensure the point calculation logic is correct for various `cluesRead` values.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Integrate Game Session Persistence with IndexedDB",
        "description": "Persist the game session state to IndexedDB to allow players to resume a game after a page refresh. Use the 'idb' library for a clean, promise-based API.",
        "details": "Create a utility module for IndexedDB interactions using the `idb` library. Subscribe to the Zustand store. Whenever the state changes, serialize it and save it to an IndexedDB object store. When the application loads, attempt to read from IndexedDB to rehydrate the store's initial state. This ensures the game state (players, scores, current turn) persists.",
        "testStrategy": "This is difficult to test in a pure Node environment. Write integration tests that run in a browser context (e.g., using Playwright or Cypress if added, or manual testing). For unit tests, mock the `idb` library to verify that the save/load functions are called correctly on store updates and application initialization.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Final Scoreboard and Game End Flow",
        "description": "Create the final scoreboard view that is displayed when the MC ends the game. The scoreboard should list all players ranked by their final scores.",
        "details": "Create a new Astro page `src/pages/scoreboard.astro` or a conditional view within the main game island. This component will read the final player list from the Zustand store, sort it by score in descending order, and display the results using a `Table` from `shadcn/ui`. Add a 'Finish Game' button to the main game UI that triggers the `endGame` action and navigates to this view.",
        "testStrategy": "Use React Testing Library to test the scoreboard component with a mock state containing a list of players with various scores. Verify that the players are rendered in the correct order. Use `@astrojs/testing` to test the navigation flow from the game page to the scoreboard page upon ending the game.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-08T14:18:57.049Z",
      "updated": "2025-11-08T14:35:21.786Z",
      "description": "Tasks for master context"
    }
  }
}